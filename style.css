html{
    
    background: #f7f7f7;
}

body{
    background: white;
    margin: 0 auto;
    font-family: 'Barlow', sans-serif;
    text-align: center;
}

header, footer{
    background: #333a40;
    color:white;
    padding: 20px 10px;
    
    
}

input[type="search"]{
    
    width: 100%;
}



ul{
      margin: 0;
      padding: 0;
  
}

li{
    list-style: none;
    line-height: 30px;
    
    
}

a{
    text-decoration: none;
    color: inherit;
}

a:hover{
    color: #0e69e9;
    
}
 header li{
    display: inline;
    
}

header h1, nav{
    
    display: inline-block;
}

header h1{
/*    width: 70%;*/
    width: 100%;
}

.product{
   box-sizing:border-box;
    border: 1px solid grey;
/*    width: 30%;*/
    margin: 5px;
    padding: 5px;
/*    display: inline-block;*/
    text-align: center;
    width: 98%;
    
 }

img{
    max-width: 100% ;
}

.button{
    
    padding: 10px;
    display: inline-block;
}

.button:last-of-type{
    
    background: #0e69e9;
    color: white;
    
}

/*Product Detail page*/

.product-detail{
    width: 660px;
    
}
.product-detail img {
    max-width: 50%;
    float: left;
}

/*Contact us */

form{
    padding: 10px;
    margin: 10px 0;
    width: 600px;
}

form > div{
    margin: 10px 0;
}

.inline label{
    display: inline-block;
    width: 100px;
}

input[type="text"], input[type="email"], textarea{
    padding: 10px;
    width: 400px;
    
    
}

/*table*/


table, th, td{
    
    
    padding: 5px;
    width: 400px;
    text-align: left;
    margin: 5px;

    
}

table caption{
    margin: 10px;
    border-bottom: 1px solid;
}

@media (min-width: 800px)
{
    input[type="search"]{
        width:40%;
        margin-left: 2em;
    }
    
    .product{
    width: 48%;
   display: inline-block;
    
 }
    
}


/* target/context =  result: this is how we convert a pixel size to a fluid size  */
/* 680/1000px = 0.68 *100 = 68%*/

@media (min-width: 1000px){
    
    body{
        text-align: left;
    }
    
     header h1{
    width: 70%;

}
    
main{

    width: 68%;
    display: inline-block;
    padding: 20px 10px;
}
    

    
    input[type="search"]{
    
    width: 10%;
}

aside{
    
    width: 27%;
    display: inline-block;
    vertical-align: top;
    padding: 10px;
}
    
 
      
}

@media (min-width: 1200px) {
    
    body{
        max-width: 80vm;
    }
    
    .product{
        width: 30%;
    }
    
    
    
}

 



/*

1. Target. you can target specific areas of the HTML by adding the tag name like Header, body, hMTL, Footer, IMG or a like. you can target specific areas nested inside any of the main tags of the HTML for example header h1{} and also you can targer multiple areas by adding a comma follow by the next tag ej: header h1, nav o main areas ej body, html{}.

2. Display: inline, inline block block

    A. display inline: will display the object in one line of the document 
    B. inline block: will display the document in one line and but will also let you control the width and height. 
    C. Block: it add a line breaf after the element so the elements wont sit next to each other. 
    D. When using inline elemnents we cant add margin or padding to the left and right btu we can do it to the top a bottom

3. styling lines: target li{} :

    A. List-style: none, inside, url, circle, squre amoing others
    B. line-height: space btw each line. 

4. pseudo classes: you can do different actions wit the pseudo classes, like changing the color when the mouse moves over, changing the color when you already click the link and so forth. to add a speudo class you need to write

a + : + the name of the claass + {}.
    
    A. we can select an specific tag and number of type of class, to change or add properties:

ej: p:first-of-type: will select all the first of an type. see exampple with p's on css. you can also selcet the last of type or target an specific element by using 
NTH-OF-TYPE(X), where X is going to be the target element of the specific list or content.

5. Float: Will set an element to float on the side of the elements inside the objct. 

A.*** be aware float does not account for heigth only for wide. so in case you come across the problem of the next element coming towards the float, you can use overflow:auto. look for clearfix.

b. Clear, will clear the element to not float on the right floating element, left or both. 

6.  Property: to position elmeents, there are 5:

    A. Static: the elements will be palce where they wold normally be in the flow or the documents. This is the default setting.


    B. Relative: Plaes the elements where they would normally be, but takes in to account top, bottom, left and right to offset the elements. and it doesnt affect any of the surranding elements.

    C. Absolute: it take the elements out of the normal flow of the document, it will not be place in the next available space, there is no space create it for it. It will be reference to the top of the web, or to be more precice to the HTML container elements. To reference to another parent element, we will need to set the position of such element ot be relative.  

    D. Fixed: It will reference to the html. but will mantian his position while scrolling down the page. To reference to another parent element, we will need to set the position of such element ot be relative. Fixed position will not occupy any space in the body, so the next element(eg: an image) will be behind the fixed element


    E. Sticky:The element is positioned according to the normal flow of the document, and then offset relative to its nearest scrolling ancestor and containing block (nearest block-level ancestor), including table-related elements, based on the values of top, right, bottom, and left. The offset does not affect the position of any other elements. It will make the object stay in place,sticky position occupies the space, so the next element will not be hidden behind it.

7. child combinator (>):The element>element selector is used to select elements with a specific parent.

8. Objex[type="X"]: selector is used to select elements with an attribute value containing a specified word, or type.

*/


/*RESPONSIVE WEBSITE*/

/* <meta name="viewport" content="width=device-width, initial-scale=1.0"

In every document that you work, you want to use the meta tag as above. you want to set up the content to "width+device-widht". we dont use a fixed number because there are too many different screen sizes and we need our webiste to fit them all, inside of the "" after width we want to add a ',' and use the inital-scale=1.0, so the device doesnt zoom out the webiste to see all the objects. 

>*/


/*relative or scalable units*/

/*When working with responsive websites, you dont really want to work with PX units (its Fixed), you want to use more flexible units(%. VW, VH):

1. Using % the page wil shrink or strech to the X% of the available space, in can be use with main tags and nested tags.



2. Viewport : is the visible are of the user of the screen

    2.1 VW="View width"
    2.2 VH="View height"

3. EM and REM:

    3.1 em realtes to the parent section .The em unit allows setting the font size of an element relative to the font size of its parent. When the size of the parent element changes, the size of the child changes automatically.

        3.1.1 When em units are used on font-size property, the size is relative to the font-size of the parent. When used on other properties, it’s relative to the font-size of that element itself. Here, only the first declaration takes the reference of the parent.

    3.2 rem is based upon the font-size value of the root element, which is the <html> element. And if the <html> element doesn’t have a specified font-size, the browser default value of 16px is used. So here only the value of the root is considered, and there is no relation with a parent element.

        3.2.1Unlike em, here size is relative for all declarations, not only first. Let’s understand this with our previous example.

    4. Media queries: allow us to change layout based on the users device size, orientation or resolution amoung others. ie: we can have css rules for screens over 600 pixels, on 600 wide===

    1. to be able to call a media queris you write
@media () {}. we can use AND to mix 1 or 2 more queries ei:           @media (xxxx) and (xxxx){}

    2. when the styling change accurs it is call the Breakpoints.

    3. Is a good idea to start with the browser really narrow, and then apply general CSS, then strech the browser wider and only apply a media query to change layouts when th desing begins to look streched or not quite right. 

    4. We used AND to mix media queries. you can also use not and only logical operators to make more complex media queries.

*/


/*Styling for small screens */

 /*   

A good starting point is to often make the content for width and also centered.

*/

